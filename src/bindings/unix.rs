/* automatically generated by rust-bindgen */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = "  @brief A srtp_cipher_type_id_t is an identifier for a particular cipher"]
#[doc = "  type."]
#[doc = ""]
#[doc = "  A srtp_cipher_type_id_t is an integer that represents a particular"]
#[doc = "  cipher type, e.g. the Advanced Encryption Standard (AES).  A"]
#[doc = "  SRTP_NULL_CIPHER is available; this cipher leaves the data unchanged,"]
#[doc = "  and can be selected to indicate that no encryption is to take"]
#[doc = "  place."]
#[doc = ""]
#[doc = "  @ingroup Ciphers"]
pub type srtp_cipher_type_id_t = u32;
#[doc = "  @brief An srtp_auth_type_id_t is an identifier for a particular"]
#[doc = " authentication"]
#[doc = "   function."]
#[doc = ""]
#[doc = "  An srtp_auth_type_id_t is an integer that represents a particular"]
#[doc = "  authentication function type, e.g. HMAC-SHA1.  A SRTP_NULL_AUTH is"]
#[doc = "  available; this authentication function performs no computation,"]
#[doc = "  and can be selected to indicate that no authentication is to take"]
#[doc = "  place."]
#[doc = ""]
#[doc = "  @ingroup Authentication"]
pub type srtp_auth_type_id_t = u32;
#[doc = "< nothing to report"]
pub const srtp_err_status_t_srtp_err_status_ok: srtp_err_status_t = 0;
#[doc = "< unspecified failure"]
pub const srtp_err_status_t_srtp_err_status_fail: srtp_err_status_t = 1;
#[doc = "< unsupported parameter"]
pub const srtp_err_status_t_srtp_err_status_bad_param: srtp_err_status_t = 2;
#[doc = "< couldn't allocate memory"]
pub const srtp_err_status_t_srtp_err_status_alloc_fail: srtp_err_status_t = 3;
#[doc = "< couldn't deallocate properly"]
pub const srtp_err_status_t_srtp_err_status_dealloc_fail: srtp_err_status_t = 4;
#[doc = "< couldn't initialize"]
pub const srtp_err_status_t_srtp_err_status_init_fail: srtp_err_status_t = 5;
#[doc = "< can't process as much data as   */"]
pub const srtp_err_status_t_srtp_err_status_terminus: srtp_err_status_t = 6;
#[doc = "< authentication failure"]
pub const srtp_err_status_t_srtp_err_status_auth_fail: srtp_err_status_t = 7;
#[doc = "< cipher failure"]
pub const srtp_err_status_t_srtp_err_status_cipher_fail: srtp_err_status_t = 8;
#[doc = "< replay check failed (bad index)"]
pub const srtp_err_status_t_srtp_err_status_replay_fail: srtp_err_status_t = 9;
#[doc = "< replay check failed (index too  */"]
pub const srtp_err_status_t_srtp_err_status_replay_old: srtp_err_status_t = 10;
#[doc = "< algorithm failed test routine"]
pub const srtp_err_status_t_srtp_err_status_algo_fail: srtp_err_status_t = 11;
#[doc = "< unsupported operation"]
pub const srtp_err_status_t_srtp_err_status_no_such_op: srtp_err_status_t = 12;
#[doc = "< no appropriate context found"]
pub const srtp_err_status_t_srtp_err_status_no_ctx: srtp_err_status_t = 13;
#[doc = "< unable to perform desired       */"]
pub const srtp_err_status_t_srtp_err_status_cant_check: srtp_err_status_t = 14;
#[doc = "< can't use key any more"]
pub const srtp_err_status_t_srtp_err_status_key_expired: srtp_err_status_t = 15;
#[doc = "< error in use of socket"]
pub const srtp_err_status_t_srtp_err_status_socket_err: srtp_err_status_t = 16;
#[doc = "< error in use POSIX signals"]
pub const srtp_err_status_t_srtp_err_status_signal_err: srtp_err_status_t = 17;
#[doc = "< nonce check failed"]
pub const srtp_err_status_t_srtp_err_status_nonce_bad: srtp_err_status_t = 18;
#[doc = "< couldn't read data"]
pub const srtp_err_status_t_srtp_err_status_read_fail: srtp_err_status_t = 19;
#[doc = "< couldn't write data"]
pub const srtp_err_status_t_srtp_err_status_write_fail: srtp_err_status_t = 20;
#[doc = "< error parsing data"]
pub const srtp_err_status_t_srtp_err_status_parse_err: srtp_err_status_t = 21;
#[doc = "< error encoding data"]
pub const srtp_err_status_t_srtp_err_status_encode_err: srtp_err_status_t = 22;
#[doc = "< error while using semaphores"]
pub const srtp_err_status_t_srtp_err_status_semaphore_err: srtp_err_status_t = 23;
#[doc = "< error while using pfkey"]
pub const srtp_err_status_t_srtp_err_status_pfkey_err: srtp_err_status_t = 24;
#[doc = "< error MKI present in packet is  */"]
pub const srtp_err_status_t_srtp_err_status_bad_mki: srtp_err_status_t = 25;
#[doc = "< packet index is too old to      */"]
pub const srtp_err_status_t_srtp_err_status_pkt_idx_old: srtp_err_status_t = 26;
#[doc = "< packet index advanced, reset    */"]
pub const srtp_err_status_t_srtp_err_status_pkt_idx_adv: srtp_err_status_t = 27;
#[doc = " @brief srtp_err_status_t defines error codes."]
#[doc = ""]
#[doc = " The enumeration srtp_err_status_t defines error codes.  Note that the"]
#[doc = " value of srtp_err_status_ok is equal to zero, which can simplify error"]
#[doc = " checking somewhat."]
#[doc = ""]
pub type srtp_err_status_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_ctx_t_ {
    _unused: [u8; 0],
}
pub type srtp_ctx_t = srtp_ctx_t_;
#[doc = "< no services"]
pub const srtp_sec_serv_t_sec_serv_none: srtp_sec_serv_t = 0;
#[doc = "< confidentiality"]
pub const srtp_sec_serv_t_sec_serv_conf: srtp_sec_serv_t = 1;
#[doc = "< authentication"]
pub const srtp_sec_serv_t_sec_serv_auth: srtp_sec_serv_t = 2;
#[doc = "< confidentiality and authentication"]
pub const srtp_sec_serv_t_sec_serv_conf_and_auth: srtp_sec_serv_t = 3;
#[doc = " @brief srtp_sec_serv_t describes a set of security services."]
#[doc = ""]
#[doc = " A srtp_sec_serv_t enumeration is used to describe the particular"]
#[doc = " security services that will be applied by a particular crypto"]
#[doc = " policy (or other mechanism)."]
pub type srtp_sec_serv_t = u32;
#[doc = " @brief srtp_crypto_policy_t describes a particular crypto policy that"]
#[doc = " can be applied to an SRTP stream."]
#[doc = ""]
#[doc = " A srtp_crypto_policy_t describes a particular cryptographic policy that"]
#[doc = " can be applied to an SRTP or SRTCP stream.  An SRTP session policy"]
#[doc = " consists of a list of these policies, one for each SRTP stream"]
#[doc = " in the session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_crypto_policy_t {
    #[doc = "< An integer representing          */"]
    pub cipher_type: srtp_cipher_type_id_t,
    #[doc = "< The length of the cipher key     */"]
    pub cipher_key_len: ::std::os::raw::c_int,
    #[doc = "< An integer representing the      */"]
    pub auth_type: srtp_auth_type_id_t,
    #[doc = "< The length of the authentication */"]
    pub auth_key_len: ::std::os::raw::c_int,
    #[doc = "< The length of the authentication */"]
    pub auth_tag_len: ::std::os::raw::c_int,
    #[doc = "< The flag indicating the security */"]
    pub sec_serv: srtp_sec_serv_t,
}
#[test]
fn bindgen_test_layout_srtp_crypto_policy_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_crypto_policy_t>(),
        24usize,
        concat!("Size of: ", stringify!(srtp_crypto_policy_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_crypto_policy_t>(),
        4usize,
        concat!("Alignment of ", stringify!(srtp_crypto_policy_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_crypto_policy_t>())).cipher_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(cipher_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_crypto_policy_t>())).cipher_key_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(cipher_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_crypto_policy_t>())).auth_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(auth_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_crypto_policy_t>())).auth_key_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(auth_key_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_crypto_policy_t>())).auth_tag_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(auth_tag_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_crypto_policy_t>())).sec_serv as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_crypto_policy_t),
            "::",
            stringify!(sec_serv)
        )
    );
}
#[doc = "< Indicates an undefined SSRC type."]
pub const srtp_ssrc_type_t_ssrc_undefined: srtp_ssrc_type_t = 0;
#[doc = "< Indicates a specific SSRC value"]
pub const srtp_ssrc_type_t_ssrc_specific: srtp_ssrc_type_t = 1;
#[doc = "< Indicates any inbound SSRC value     */"]
pub const srtp_ssrc_type_t_ssrc_any_inbound: srtp_ssrc_type_t = 2;
#[doc = "< Indicates any outbound SSRC value    */"]
pub const srtp_ssrc_type_t_ssrc_any_outbound: srtp_ssrc_type_t = 3;
#[doc = " @brief srtp_ssrc_type_t describes the type of an SSRC."]
#[doc = ""]
#[doc = " An srtp_ssrc_type_t enumeration is used to indicate a type of SSRC.  See"]
#[doc = " @ref srtp_policy_t for more information."]
pub type srtp_ssrc_type_t = u32;
#[doc = " @brief An srtp_ssrc_t represents a particular SSRC value, or a `wildcard'"]
#[doc = " SSRC."]
#[doc = ""]
#[doc = " An srtp_ssrc_t represents a particular SSRC value (if its type is"]
#[doc = " ssrc_specific), or a wildcard SSRC value that will match all"]
#[doc = " outbound SSRCs (if its type is ssrc_any_outbound) or all inbound"]
#[doc = " SSRCs (if its type is ssrc_any_inbound)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_ssrc_t {
    #[doc = "< The type of this particular SSRC"]
    pub type_: srtp_ssrc_type_t,
    #[doc = "< The value of this SSRC, if it is not a */"]
    pub value: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_srtp_ssrc_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_ssrc_t>(),
        8usize,
        concat!("Size of: ", stringify!(srtp_ssrc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_ssrc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(srtp_ssrc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_ssrc_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_ssrc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_ssrc_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_ssrc_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_ekt_policy_ctx_t {
    _unused: [u8; 0],
}
#[doc = " @brief points to an EKT policy"]
pub type srtp_ekt_policy_t = *mut srtp_ekt_policy_ctx_t;
#[doc = " @brief srtp_master_key_t represents a master key.  There will"]
#[doc = " be a Master Key Index and the Master Key associated with the"]
#[doc = " Master Key Index.  Need to also keep track of the Master Key"]
#[doc = " Index Size to correctly read it from a packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_master_key_t {
    pub key: *mut ::std::os::raw::c_uchar,
    pub mki_id: *mut ::std::os::raw::c_uchar,
    pub mki_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_srtp_master_key_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_master_key_t>(),
        24usize,
        concat!("Size of: ", stringify!(srtp_master_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_master_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_master_key_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_master_key_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_master_key_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_master_key_t>())).mki_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_master_key_t),
            "::",
            stringify!(mki_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_master_key_t>())).mki_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_master_key_t),
            "::",
            stringify!(mki_size)
        )
    );
}
#[doc = " @brief represents the policy for an SRTP session."]
#[doc = ""]
#[doc = " A single srtp_policy_t struct represents the policy for a single"]
#[doc = " SRTP stream, and a linked list of these elements represents the"]
#[doc = " policy for an entire SRTP session.  Each element contains the SRTP"]
#[doc = " and SRTCP crypto policies for that stream, a pointer to the SRTP"]
#[doc = " master key for that stream, the SSRC describing that stream, or a"]
#[doc = " flag indicating a `wildcard' SSRC value, and a `next' field that"]
#[doc = " holds a pointer to the next element in the list of policy elements,"]
#[doc = " or NULL if it is the last element."]
#[doc = ""]
#[doc = " The wildcard value SSRC_ANY_INBOUND matches any SSRC from an"]
#[doc = " inbound stream that for which there is no explicit SSRC entry in"]
#[doc = " another policy element.  Similarly, the value SSRC_ANY_OUTBOUND"]
#[doc = " will matches any SSRC from an outbound stream that does not appear"]
#[doc = " in another policy element.  Note that wildcard SSRCs &b cannot be"]
#[doc = " used to match both inbound and outbound traffic.  This restriction"]
#[doc = " is intentional, and it allows libSRTP to ensure that no security"]
#[doc = " lapses result from accidental re-use of SSRC values during key"]
#[doc = " sharing."]
#[doc = ""]
#[doc = " @warning The final element of the list @b must have its `next' pointer"]
#[doc = "          set to NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_policy_t {
    #[doc = "< The SSRC value of stream, or the    */"]
    pub ssrc: srtp_ssrc_t,
    #[doc = "< SRTP crypto policy."]
    pub rtp: srtp_crypto_policy_t,
    #[doc = "< SRTCP crypto policy."]
    pub rtcp: srtp_crypto_policy_t,
    #[doc = "< Pointer to the SRTP master key for  */"]
    pub key: *mut ::std::os::raw::c_uchar,
    pub keys: *mut *mut srtp_master_key_t,
    #[doc = " Array of Master Key structures"]
    pub num_master_keys: ::std::os::raw::c_ulong,
    #[doc = "< Pointer to the EKT policy structure */"]
    pub ekt: srtp_ekt_policy_t,
    #[doc = "< The window size to use for replay   */"]
    pub window_size: ::std::os::raw::c_ulong,
    #[doc = "< Whether retransmissions of          */"]
    pub allow_repeat_tx: ::std::os::raw::c_int,
    #[doc = "< List of header ids to encrypt."]
    pub enc_xtn_hdr: *mut ::std::os::raw::c_int,
    #[doc = "< Number of entries in list of header */"]
    pub enc_xtn_hdr_count: ::std::os::raw::c_int,
    #[doc = "< Pointer to next stream policy."]
    pub next: *mut srtp_policy_t,
}
#[test]
fn bindgen_test_layout_srtp_policy_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_policy_t>(),
        128usize,
        concat!("Size of: ", stringify!(srtp_policy_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_policy_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_policy_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).ssrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).rtp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(rtp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).rtcp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(rtcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).keys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).num_master_keys as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(num_master_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).ekt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(ekt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).window_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).allow_repeat_tx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(allow_repeat_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).enc_xtn_hdr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(enc_xtn_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).enc_xtn_hdr_count as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(enc_xtn_hdr_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_policy_t>())).next as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_policy_t),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " @brief An srtp_t points to an SRTP session structure."]
#[doc = ""]
#[doc = " The typedef srtp_t is a pointer to a structure that represents"]
#[doc = " an SRTP session.  This datatype is intentionally opaque in"]
#[doc = " order to separate the interface from the implementation."]
#[doc = ""]
#[doc = " An SRTP session consists of all of the traffic sent to the RTP and"]
#[doc = " RTCP destination transport addresses, using the RTP/SAVP (Secure"]
#[doc = " Audio/Video Profile).  A session can be viewed as a set of SRTP"]
#[doc = " streams, each of which originates with a different participant."]
pub type srtp_t = *mut srtp_ctx_t;
extern "C" {
    #[doc = " @brief srtp_init() initializes the srtp library."]
    #[doc = ""]
    #[doc = " @warning This function @b must be called before any other srtp"]
    #[doc = " functions."]
    pub fn srtp_init() -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_shutdown() de-initializes the srtp library."]
    #[doc = ""]
    #[doc = " @warning No srtp functions may be called after calling this function."]
    pub fn srtp_shutdown() -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_protect() is the Secure RTP sender-side packet processing"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " The function call srtp_protect(ctx, rtp_hdr, len_ptr) applies SRTP"]
    #[doc = " protection to the RTP packet rtp_hdr (which has length *len_ptr) using"]
    #[doc = " the SRTP context ctx.  If srtp_err_status_ok is returned, then rtp_hdr"]
    #[doc = " points to the resulting SRTP packet and *len_ptr is the number of"]
    #[doc = " octets in that packet; otherwise, no assumptions should be made"]
    #[doc = " about the value of either data elements."]
    #[doc = ""]
    #[doc = " The sequence numbers of the RTP packets presented to this function"]
    #[doc = " need not be consecutive, but they @b must be out of order by less"]
    #[doc = " than 2^15 = 32,768 packets."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write the authentication"]
    #[doc = " tag into the location in memory immediately following the RTP"]
    #[doc = " packet, and assumes that the RTP packet is aligned on a 32-bit"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write SRTP_MAX_TRAILER_LEN"]
    #[doc = " into the location in memory immediately following the RTP packet."]
    #[doc = " Callers MUST ensure that this much writable memory is available in"]
    #[doc = " the buffer that holds the RTP packet."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP context to use in processing the packet."]
    #[doc = ""]
    #[doc = " @param rtp_hdr is a pointer to the RTP packet (before the call); after"]
    #[doc = " the function returns, it points to the srtp packet."]
    #[doc = ""]
    #[doc = " @param len_ptr is a pointer to the length in octets of the complete"]
    #[doc = " RTP packet (header and body) before the function call, and of the"]
    #[doc = " complete SRTP packet after the call, if srtp_err_status_ok was returned."]
    #[doc = " Otherwise, the value of the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok            no problems"]
    #[doc = "    - srtp_err_status_replay_fail   rtp sequence number was non-increasing"]
    #[doc = "    - @e other                 failure in cryptographic mechanisms"]
    pub fn srtp_protect(
        ctx: srtp_t,
        rtp_hdr: *mut ::std::os::raw::c_void,
        len_ptr: *mut ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_protect_mki() is the Secure RTP sender-side packet processing"]
    #[doc = " function that can utilize MKI."]
    #[doc = ""]
    #[doc = " The function call srtp_protect(ctx, rtp_hdr, len_ptr) applies SRTP"]
    #[doc = " protection to the RTP packet rtp_hdr (which has length *len_ptr) using"]
    #[doc = " the SRTP context ctx.  If srtp_err_status_ok is returned, then rtp_hdr"]
    #[doc = " points to the resulting SRTP packet and *len_ptr is the number of"]
    #[doc = " octets in that packet; otherwise, no assumptions should be made"]
    #[doc = " about the value of either data elements."]
    #[doc = ""]
    #[doc = " The sequence numbers of the RTP packets presented to this function"]
    #[doc = " need not be consecutive, but they @b must be out of order by less"]
    #[doc = " than 2^15 = 32,768 packets."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write the authentication"]
    #[doc = " tag into the location in memory immediately following the RTP"]
    #[doc = " packet, and assumes that the RTP packet is aligned on a 32-bit"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write SRTP_MAX_TRAILER_LEN"]
    #[doc = " into the location in memory immediately following the RTP packet."]
    #[doc = " Callers MUST ensure that this much writable memory is available in"]
    #[doc = " the buffer that holds the RTP packet."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP context to use in processing the packet."]
    #[doc = ""]
    #[doc = " @param rtp_hdr is a pointer to the RTP packet (before the call); after"]
    #[doc = " the function returns, it points to the srtp packet."]
    #[doc = ""]
    #[doc = " @param pkt_octet_len is a pointer to the length in octets of the complete"]
    #[doc = " RTP packet (header and body) before the function call, and of the"]
    #[doc = " complete SRTP packet after the call, if srtp_err_status_ok was returned."]
    #[doc = " Otherwise, the value of the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param use_mki is a boolean to tell the system if mki is being used.  If"]
    #[doc = " set to false then will use the first set of session keys.  If set to true"]
    #[doc = " will"]
    #[doc = " use the session keys identified by the mki_index"]
    #[doc = ""]
    #[doc = " @param mki_index integer value specifying which set of session keys should be"]
    #[doc = " used if use_mki is set to true."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok            no problems"]
    #[doc = "    - srtp_err_status_replay_fail   rtp sequence number was non-increasing"]
    #[doc = "    - @e other                 failure in cryptographic mechanisms"]
    pub fn srtp_protect_mki(
        ctx: *mut srtp_ctx_t,
        rtp_hdr: *mut ::std::os::raw::c_void,
        pkt_octet_len: *mut ::std::os::raw::c_int,
        use_mki: ::std::os::raw::c_uint,
        mki_index: ::std::os::raw::c_uint,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_unprotect() is the Secure RTP receiver-side packet"]
    #[doc = " processing function."]
    #[doc = ""]
    #[doc = " The function call srtp_unprotect(ctx, srtp_hdr, len_ptr) verifies"]
    #[doc = " the Secure RTP protection of the SRTP packet pointed to by srtp_hdr"]
    #[doc = " (which has length *len_ptr), using the SRTP context ctx.  If"]
    #[doc = " srtp_err_status_ok is returned, then srtp_hdr points to the resulting"]
    #[doc = " RTP packet and *len_ptr is the number of octets in that packet;"]
    #[doc = " otherwise, no assumptions should be made about the value of either"]
    #[doc = " data elements."]
    #[doc = ""]
    #[doc = " The sequence numbers of the RTP packets presented to this function"]
    #[doc = " need not be consecutive, but they @b must be out of order by less"]
    #[doc = " than 2^15 = 32,768 packets."]
    #[doc = ""]
    #[doc = " @warning This function assumes that the SRTP packet is aligned on a"]
    #[doc = " 32-bit boundary."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP session which applies to the particular packet."]
    #[doc = ""]
    #[doc = " @param srtp_hdr is a pointer to the header of the SRTP packet"]
    #[doc = " (before the call).  after the function returns, it points to the"]
    #[doc = " rtp packet if srtp_err_status_ok was returned; otherwise, the value of"]
    #[doc = " the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param len_ptr is a pointer to the length in octets of the complete"]
    #[doc = " srtp packet (header and body) before the function call, and of the"]
    #[doc = " complete rtp packet after the call, if srtp_err_status_ok was returned."]
    #[doc = " Otherwise, the value of the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok          if the RTP packet is valid."]
    #[doc = "    - srtp_err_status_auth_fail   if the SRTP packet failed the message"]
    #[doc = "                                  authentication check."]
    #[doc = "    - srtp_err_status_replay_fail if the SRTP packet is a replay (e.g. packet"]
    #[doc = "                                  has already been processed and accepted)."]
    #[doc = "    - [other]  if there has been an error in the cryptographic mechanisms."]
    #[doc = ""]
    pub fn srtp_unprotect(
        ctx: srtp_t,
        srtp_hdr: *mut ::std::os::raw::c_void,
        len_ptr: *mut ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_unprotect_mki() is the Secure RTP receiver-side packet"]
    #[doc = " processing function that checks for MKI."]
    #[doc = ""]
    #[doc = " The function call srtp_unprotect(ctx, srtp_hdr, len_ptr) verifies"]
    #[doc = " the Secure RTP protection of the SRTP packet pointed to by srtp_hdr"]
    #[doc = " (which has length *len_ptr), using the SRTP context ctx.  If"]
    #[doc = " srtp_err_status_ok is returned, then srtp_hdr points to the resulting"]
    #[doc = " RTP packet and *len_ptr is the number of octets in that packet;"]
    #[doc = " otherwise, no assumptions should be made about the value of either"]
    #[doc = " data elements."]
    #[doc = ""]
    #[doc = " The sequence numbers of the RTP packets presented to this function"]
    #[doc = " need not be consecutive, but they @b must be out of order by less"]
    #[doc = " than 2^15 = 32,768 packets."]
    #[doc = ""]
    #[doc = " @warning This function assumes that the SRTP packet is aligned on a"]
    #[doc = " 32-bit boundary."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP session which applies to the particular packet."]
    #[doc = ""]
    #[doc = " @param srtp_hdr is a pointer to the header of the SRTP packet"]
    #[doc = " (before the call).  after the function returns, it points to the"]
    #[doc = " rtp packet if srtp_err_status_ok was returned; otherwise, the value of"]
    #[doc = " the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param len_ptr is a pointer to the length in octets of the complete"]
    #[doc = " srtp packet (header and body) before the function call, and of the"]
    #[doc = " complete rtp packet after the call, if srtp_err_status_ok was returned."]
    #[doc = " Otherwise, the value of the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param use_mki is a boolean to tell the system if mki is being used.  If"]
    #[doc = " set to false then will use the first set of session keys.  If set to true"]
    #[doc = " will"]
    #[doc = " use the session keys identified by the mki_index"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok          if the RTP packet is valid."]
    #[doc = "    - srtp_err_status_auth_fail   if the SRTP packet failed the message"]
    #[doc = "                                  authentication check."]
    #[doc = "    - srtp_err_status_replay_fail if the SRTP packet is a replay (e.g. packet"]
    #[doc = "                                  has already been processed and accepted)."]
    #[doc = "    - srtp_err_status_bad_mki if the MKI in the packet is not a known MKI id"]
    #[doc = "    - [other]  if there has been an error in the cryptographic mechanisms."]
    #[doc = ""]
    pub fn srtp_unprotect_mki(
        ctx: srtp_t,
        srtp_hdr: *mut ::std::os::raw::c_void,
        len_ptr: *mut ::std::os::raw::c_int,
        use_mki: ::std::os::raw::c_uint,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_create() allocates and initializes an SRTP session."]
    #[doc = ""]
    #[doc = " The function call srtp_create(session, policy) allocates and"]
    #[doc = " initializes an SRTP session context, applying the given policy."]
    #[doc = ""]
    #[doc = " @param session is a pointer to the SRTP session to which the policy is"]
    #[doc = " to be added."]
    #[doc = ""]
    #[doc = " @param policy is the srtp_policy_t struct that describes the policy"]
    #[doc = " for the session.  The struct may be a single element, or it may be"]
    #[doc = " the head of a list, in which case each element of the list is"]
    #[doc = " processed.  It may also be NULL, in which case streams should be added"]
    #[doc = " later using srtp_add_stream().  The final element of the list @b must"]
    #[doc = " have its `next' field set to NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok           if creation succeeded."]
    #[doc = "    - srtp_err_status_alloc_fail   if allocation failed."]
    #[doc = "    - srtp_err_status_init_fail    if initialization failed."]
    pub fn srtp_create(session: *mut srtp_t, policy: *const srtp_policy_t) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_add_stream() allocates and initializes an SRTP stream"]
    #[doc = " within a given SRTP session."]
    #[doc = ""]
    #[doc = " The function call srtp_add_stream(session, policy) allocates and"]
    #[doc = " initializes a new SRTP stream within a given, previously created"]
    #[doc = " session, applying the policy given as the other argument to that"]
    #[doc = " stream."]
    #[doc = ""]
    #[doc = " @return values:"]
    #[doc = "    - srtp_err_status_ok           if stream creation succeeded."]
    #[doc = "    - srtp_err_status_alloc_fail   if stream allocation failed"]
    #[doc = "    - srtp_err_status_init_fail    if stream initialization failed."]
    pub fn srtp_add_stream(session: srtp_t, policy: *const srtp_policy_t) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_remove_stream() deallocates an SRTP stream."]
    #[doc = ""]
    #[doc = " The function call srtp_remove_stream(session, ssrc) removes"]
    #[doc = " the SRTP stream with the SSRC value ssrc from the SRTP session"]
    #[doc = " context given by the argument session."]
    #[doc = ""]
    #[doc = " @param session is the SRTP session from which the stream"]
    #[doc = "        will be removed."]
    #[doc = ""]
    #[doc = " @param ssrc is the SSRC value of the stream to be removed"]
    #[doc = "             in network byte order."]
    #[doc = ""]
    #[doc = " @warning Wildcard SSRC values cannot be removed from a"]
    #[doc = "          session."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok     if the stream deallocation succeeded."]
    #[doc = "    - [other]           otherwise."]
    #[doc = ""]
    pub fn srtp_remove_stream(session: srtp_t, ssrc: ::std::os::raw::c_uint) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_update() updates all streams in the session."]
    #[doc = ""]
    #[doc = " The function call srtp_update(session, policy) updates"]
    #[doc = " all the streams in the session applying the given policy"]
    #[doc = " and key. The existing ROC value of all streams will be"]
    #[doc = " preserved."]
    #[doc = ""]
    #[doc = " @param session is the SRTP session that contains the streams"]
    #[doc = "        to be updated."]
    #[doc = ""]
    #[doc = " @param policy is the srtp_policy_t struct that describes the policy"]
    #[doc = " for the session.  The struct may be a single element, or it may be"]
    #[doc = " the head of a list, in which case each element of the list is"]
    #[doc = " processed. The final element of the list @b must"]
    #[doc = " have its `next' field set to NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok           if stream creation succeed."]
    #[doc = "    - srtp_err_status_alloc_fail   if stream allocation failed"]
    #[doc = "    - srtp_err_status_init_fail    if stream initialization failed."]
    #[doc = "    - [other]                 otherwise."]
    #[doc = ""]
    pub fn srtp_update(session: srtp_t, policy: *const srtp_policy_t) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_update_stream() updates a SRTP stream."]
    #[doc = ""]
    #[doc = " The function call srtp_update_stream(session, policy) updates"]
    #[doc = " the stream(s) in the session that match applying the given"]
    #[doc = " policy and key. The existing ROC value of all stream(s) will"]
    #[doc = " be preserved."]
    #[doc = ""]
    #[doc = " @param session is the SRTP session that contains the streams"]
    #[doc = "        to be updated."]
    #[doc = ""]
    #[doc = " @param policy is the srtp_policy_t struct that describes the policy"]
    #[doc = " for the session."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok           if stream creation succeeded."]
    #[doc = "    - srtp_err_status_alloc_fail   if stream allocation failed"]
    #[doc = "    - srtp_err_status_init_fail    if stream initialization failed."]
    #[doc = "    - [other]                      otherwise."]
    #[doc = ""]
    pub fn srtp_update_stream(session: srtp_t, policy: *const srtp_policy_t) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_rtp_default() sets a crypto policy"]
    #[doc = " structure to the SRTP default policy for RTP protection."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_rtp_default(&p) sets the"]
    #[doc = " srtp_crypto_policy_t at location p to the SRTP default policy for RTP"]
    #[doc = " protection, as defined in the specification.  This function is a"]
    #[doc = " convenience that helps to avoid dealing directly with the policy"]
    #[doc = " data structure.  You are encouraged to initialize policy elements"]
    #[doc = " with this function call.  Doing so may allow your code to be"]
    #[doc = " forward compatible with later versions of libSRTP that include more"]
    #[doc = " elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_rtp_default(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_rtcp_default() sets a crypto policy"]
    #[doc = " structure to the SRTP default policy for RTCP protection."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_rtcp_default(&p) sets the"]
    #[doc = " srtp_crypto_policy_t at location p to the SRTP default policy for RTCP"]
    #[doc = " protection, as defined in the specification.  This function is a"]
    #[doc = " convenience that helps to avoid dealing directly with the policy"]
    #[doc = " data structure.  You are encouraged to initialize policy elements"]
    #[doc = " with this function call.  Doing so may allow your code to be"]
    #[doc = " forward compatible with later versions of libSRTP that include more"]
    #[doc = " elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_rtcp_default(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32() sets a crypto"]
    #[doc = " policy structure to a short-authentication tag policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use policy"]
    #[doc = " AES_CM_128_HMAC_SHA1_32 as defined in RFC 4568."]
    #[doc = " This policy uses AES-128"]
    #[doc = " Counter Mode encryption and HMAC-SHA1 authentication, with an"]
    #[doc = " authentication tag that is only 32 bits long.  This length is"]
    #[doc = " considered adequate only for protecting audio and video media that"]
    #[doc = " use a stateless playback function.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This crypto policy is intended for use in SRTP, but not in"]
    #[doc = " SRTCP.  It is recommended that a policy that uses longer"]
    #[doc = " authentication tags be used for SRTCP.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_128_null_auth() sets a crypto"]
    #[doc = " policy structure to an encryption-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_128_null_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-128 Counter Mode), but to use no authentication method.  This"]
    #[doc = " policy is NOT RECOMMENDED unless it is unavoidable; see Section 7.5"]
    #[doc = " of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This policy is NOT RECOMMENDED for SRTP unless it is"]
    #[doc = " unavoidable, and it is NOT RECOMMENDED at all for SRTCP; see"]
    #[doc = " Section 7.5 of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_128_null_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_null_cipher_hmac_sha1_80() sets a crypto"]
    #[doc = " policy structure to an authentication-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_null_cipher_hmac_sha1_80(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use HMAC-SHA1 with an 80"]
    #[doc = " bit authentication tag to provide message authentication, but to"]
    #[doc = " use no encryption.  This policy is NOT RECOMMENDED for SRTP unless"]
    #[doc = " there is a requirement to forgo encryption."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This policy is NOT RECOMMENDED for SRTP unless there is a"]
    #[doc = " requirement to forgo encryption."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_null_cipher_hmac_sha1_80(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_null_cipher_hmac_null() sets a crypto"]
    #[doc = " policy structure to use no encryption or authentication."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_null_cipher_hmac_null(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use no encryption and"]
    #[doc = " no authentication.  This policy should only be used for testing and"]
    #[doc = " troubleshooting."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This policy is NOT RECOMMENDED for SRTP unless there is a"]
    #[doc = " requirement to forgo encryption and authentication."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_null_cipher_hmac_null(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80() sets a crypto"]
    #[doc = " policy structure to a encryption and authentication policy using AES-256"]
    #[doc = " for RTP protection."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use policy"]
    #[doc = " AES_CM_256_HMAC_SHA1_80 as defined in RFC 6188.  This policy uses AES-256"]
    #[doc = " Counter Mode encryption and HMAC-SHA1 authentication, with an 80 bit"]
    #[doc = " authentication tag."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32() sets a crypto"]
    #[doc = " policy structure to a short-authentication tag policy using AES-256"]
    #[doc = " encryption."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use policy"]
    #[doc = " AES_CM_256_HMAC_SHA1_32 as defined in RFC 6188.  This policy uses AES-256"]
    #[doc = " Counter Mode encryption and HMAC-SHA1 authentication, with an"]
    #[doc = " authentication tag that is only 32 bits long.  This length is"]
    #[doc = " considered adequate only for protecting audio and video media that"]
    #[doc = " use a stateless playback function.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This crypto policy is intended for use in SRTP, but not in"]
    #[doc = " SRTCP.  It is recommended that a policy that uses longer"]
    #[doc = " authentication tags be used for SRTCP.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_256_null_auth() sets a crypto"]
    #[doc = " policy structure to an encryption-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_256_null_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-256 Counter Mode), but to use no authentication method.  This"]
    #[doc = " policy is NOT RECOMMENDED unless it is unavoidable; see Section 7.5"]
    #[doc = " of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This policy is NOT RECOMMENDED for SRTP unless it is"]
    #[doc = " unavoidable, and it is NOT RECOMMENDED at all for SRTCP; see"]
    #[doc = " Section 7.5 of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_256_null_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_192_hmac_sha1_80() sets a crypto"]
    #[doc = " policy structure to a encryption and authentication policy using AES-192"]
    #[doc = " for RTP protection."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use policy"]
    #[doc = " AES_CM_192_HMAC_SHA1_80 as defined in RFC 6188.  This policy uses AES-192"]
    #[doc = " Counter Mode encryption and HMAC-SHA1 authentication, with an 80 bit"]
    #[doc = " authentication tag."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_192_hmac_sha1_32() sets a crypto"]
    #[doc = " policy structure to a short-authentication tag policy using AES-192"]
    #[doc = " encryption."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&p)"]
    #[doc = " sets the srtp_crypto_policy_t at location p to use policy"]
    #[doc = " AES_CM_192_HMAC_SHA1_32 as defined in RFC 6188.  This policy uses AES-192"]
    #[doc = " Counter Mode encryption and HMAC-SHA1 authentication, with an"]
    #[doc = " authentication tag that is only 32 bits long.  This length is"]
    #[doc = " considered adequate only for protecting audio and video media that"]
    #[doc = " use a stateless playback function.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This crypto policy is intended for use in SRTP, but not in"]
    #[doc = " SRTCP.  It is recommended that a policy that uses longer"]
    #[doc = " authentication tags be used for SRTCP.  See Section 7.5 of RFC 3711"]
    #[doc = " (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_cm_192_null_auth() sets a crypto"]
    #[doc = " policy structure to an encryption-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_cm_192_null_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-192 Counter Mode), but to use no authentication method.  This"]
    #[doc = " policy is NOT RECOMMENDED unless it is unavoidable; see Section 7.5"]
    #[doc = " of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @warning This policy is NOT RECOMMENDED for SRTP unless it is"]
    #[doc = " unavoidable, and it is NOT RECOMMENDED at all for SRTCP; see"]
    #[doc = " Section 7.5 of RFC 3711 (http://www.ietf.org/rfc/rfc3711.txt)."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_cm_192_null_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_128_8_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD encryption policy."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_128_8_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-128 Galois Counter Mode) with 8 octet auth tag.  This"]
    #[doc = " policy applies confidentiality and authentication to both the"]
    #[doc = " RTP and RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_128_8_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_256_8_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD encryption policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_256_8_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-256 Galois Counter Mode) with 8 octet auth tag.  This"]
    #[doc = " policy applies confidentiality and authentication to both the"]
    #[doc = " RTP and RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_256_8_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_128_8_only_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD authentication-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_128_8_only_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-128 Galois Counter Mode) with 8 octet auth tag.  This policy"]
    #[doc = " applies confidentiality and authentication to the RTP packets,"]
    #[doc = " but only authentication to the RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_128_8_only_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_256_8_only_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD authentication-only policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_256_8_only_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-256 Galois Counter Mode) with 8 octet auth tag.  This policy"]
    #[doc = " applies confidentiality and authentication to the RTP packets,"]
    #[doc = " but only authentication to the RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_256_8_only_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_128_16_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD encryption policy."]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_128_16_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-128 Galois Counter Mode) with 16 octet auth tag.  This"]
    #[doc = " policy applies confidentiality and authentication to both the"]
    #[doc = " RTP and RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_128_16_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_aes_gcm_256_16_auth() sets a crypto"]
    #[doc = " policy structure to an AEAD encryption policy"]
    #[doc = ""]
    #[doc = " @param p is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_aes_gcm_256_16_auth(&p) sets"]
    #[doc = " the srtp_crypto_policy_t at location p to use the SRTP default cipher"]
    #[doc = " (AES-256 Galois Counter Mode) with 16 octet auth tag.  This"]
    #[doc = " policy applies confidentiality and authentication to both the"]
    #[doc = " RTP and RTCP packets."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_aes_gcm_256_16_auth(p: *mut srtp_crypto_policy_t);
}
extern "C" {
    #[doc = " @brief srtp_dealloc() deallocates storage for an SRTP session"]
    #[doc = " context."]
    #[doc = ""]
    #[doc = " The function call srtp_dealloc(s) deallocates storage for the"]
    #[doc = " SRTP session context s.  This function should be called no more"]
    #[doc = " than one time for each of the contexts allocated by the function"]
    #[doc = " srtp_create()."]
    #[doc = ""]
    #[doc = " @param s is the srtp_t for the session to be deallocated."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok             if there no problems."]
    #[doc = "    - srtp_err_status_dealloc_fail   a memory deallocation failure occurred."]
    pub fn srtp_dealloc(s: srtp_t) -> srtp_err_status_t;
}
pub const srtp_profile_t_srtp_profile_reserved: srtp_profile_t = 0;
pub const srtp_profile_t_srtp_profile_aes128_cm_sha1_80: srtp_profile_t = 1;
pub const srtp_profile_t_srtp_profile_aes128_cm_sha1_32: srtp_profile_t = 2;
pub const srtp_profile_t_srtp_profile_null_sha1_80: srtp_profile_t = 5;
pub const srtp_profile_t_srtp_profile_null_sha1_32: srtp_profile_t = 6;
pub const srtp_profile_t_srtp_profile_aead_aes_128_gcm: srtp_profile_t = 7;
pub const srtp_profile_t_srtp_profile_aead_aes_256_gcm: srtp_profile_t = 8;
pub type srtp_profile_t = u32;
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_from_profile_for_rtp() sets a crypto policy"]
    #[doc = " structure to the appropriate value for RTP based on an srtp_profile_t"]
    #[doc = ""]
    #[doc = " @param policy is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " @param profile is an enumeration for the policy to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_rtp_default(&policy, profile)"]
    #[doc = " sets the srtp_crypto_policy_t at location policy to the policy for RTP"]
    #[doc = " protection, as defined by the srtp_profile_t profile."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return values"]
    #[doc = "     - srtp_err_status_ok         no problems were encountered"]
    #[doc = "     - srtp_err_status_bad_param  the profile is not supported"]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_from_profile_for_rtp(
        policy: *mut srtp_crypto_policy_t,
        profile: srtp_profile_t,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_crypto_policy_set_from_profile_for_rtcp() sets a crypto policy"]
    #[doc = " structure to the appropriate value for RTCP based on an srtp_profile_t"]
    #[doc = ""]
    #[doc = " @param policy is a pointer to the policy structure to be set"]
    #[doc = ""]
    #[doc = " @param profile is an enumeration for the policy to be set"]
    #[doc = ""]
    #[doc = " The function call srtp_crypto_policy_set_rtcp_default(&policy, profile)"]
    #[doc = " sets the srtp_crypto_policy_t at location policy to the policy for RTCP"]
    #[doc = " protection, as defined by the srtp_profile_t profile."]
    #[doc = ""]
    #[doc = " This function is a convenience that helps to avoid dealing directly"]
    #[doc = " with the policy data structure.  You are encouraged to initialize"]
    #[doc = " policy elements with this function call.  Doing so may allow your"]
    #[doc = " code to be forward compatible with later versions of libSRTP that"]
    #[doc = " include more elements in the srtp_crypto_policy_t datatype."]
    #[doc = ""]
    #[doc = " @return values"]
    #[doc = "     - srtp_err_status_ok         no problems were encountered"]
    #[doc = "     - srtp_err_status_bad_param  the profile is not supported"]
    #[doc = ""]
    pub fn srtp_crypto_policy_set_from_profile_for_rtcp(
        policy: *mut srtp_crypto_policy_t,
        profile: srtp_profile_t,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief returns the master key length for a given SRTP profile"]
    pub fn srtp_profile_get_master_key_length(profile: srtp_profile_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief returns the master salt length for a given SRTP profile"]
    pub fn srtp_profile_get_master_salt_length(profile: srtp_profile_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief appends the salt to the key"]
    #[doc = ""]
    #[doc = " The function call srtp_append_salt_to_key(k, klen, s, slen)"]
    #[doc = " copies the string s to the location at klen bytes following"]
    #[doc = " the location k."]
    #[doc = ""]
    #[doc = " @warning There must be at least bytes_in_salt + bytes_in_key bytes"]
    #[doc = "          available at the location pointed to by key."]
    #[doc = ""]
    pub fn srtp_append_salt_to_key(
        key: *mut ::std::os::raw::c_uchar,
        bytes_in_key: ::std::os::raw::c_uint,
        salt: *mut ::std::os::raw::c_uchar,
        bytes_in_salt: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief srtp_protect_rtcp() is the Secure RTCP sender-side packet"]
    #[doc = " processing function."]
    #[doc = ""]
    #[doc = " The function call srtp_protect_rtcp(ctx, rtp_hdr, len_ptr) applies"]
    #[doc = " SRTCP protection to the RTCP packet rtcp_hdr (which has length"]
    #[doc = " *len_ptr) using the SRTP session context ctx.  If srtp_err_status_ok is"]
    #[doc = " returned, then rtp_hdr points to the resulting SRTCP packet and"]
    #[doc = " *len_ptr is the number of octets in that packet; otherwise, no"]
    #[doc = " assumptions should be made about the value of either data elements."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write the authentication"]
    #[doc = " tag into the location in memory immediately following the RTCP"]
    #[doc = " packet, and assumes that the RTCP packet is aligned on a 32-bit"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write SRTP_MAX_TRAILER_LEN+4"]
    #[doc = " into the location in memory immediately following the RTCP packet."]
    #[doc = " Callers MUST ensure that this much writable memory is available in"]
    #[doc = " the buffer that holds the RTCP packet."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP context to use in processing the packet."]
    #[doc = ""]
    #[doc = " @param rtcp_hdr is a pointer to the RTCP packet (before the call); after"]
    #[doc = " the function returns, it points to the srtp packet."]
    #[doc = ""]
    #[doc = " @param pkt_octet_len is a pointer to the length in octets of the"]
    #[doc = " complete RTCP packet (header and body) before the function call,"]
    #[doc = " and of the complete SRTCP packet after the call, if srtp_err_status_ok"]
    #[doc = " was returned.  Otherwise, the value of the data to which it points"]
    #[doc = " is undefined."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok            if there were no problems."]
    #[doc = "    - [other]                  if there was a failure in"]
    #[doc = "                               the cryptographic mechanisms."]
    pub fn srtp_protect_rtcp(
        ctx: srtp_t,
        rtcp_hdr: *mut ::std::os::raw::c_void,
        pkt_octet_len: *mut ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_protect_rtcp_mki() is the Secure RTCP sender-side packet"]
    #[doc = " processing function that can utilize mki."]
    #[doc = ""]
    #[doc = " The function call srtp_protect_rtcp(ctx, rtp_hdr, len_ptr) applies"]
    #[doc = " SRTCP protection to the RTCP packet rtcp_hdr (which has length"]
    #[doc = " *len_ptr) using the SRTP session context ctx.  If srtp_err_status_ok is"]
    #[doc = " returned, then rtp_hdr points to the resulting SRTCP packet and"]
    #[doc = " *len_ptr is the number of octets in that packet; otherwise, no"]
    #[doc = " assumptions should be made about the value of either data elements."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write the authentication"]
    #[doc = " tag into the location in memory immediately following the RTCP"]
    #[doc = " packet, and assumes that the RTCP packet is aligned on a 32-bit"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " @warning This function assumes that it can write SRTP_MAX_TRAILER_LEN+4"]
    #[doc = " into the location in memory immediately following the RTCP packet."]
    #[doc = " Callers MUST ensure that this much writable memory is available in"]
    #[doc = " the buffer that holds the RTCP packet."]
    #[doc = ""]
    #[doc = " @param ctx is the SRTP context to use in processing the packet."]
    #[doc = ""]
    #[doc = " @param rtcp_hdr is a pointer to the RTCP packet (before the call); after"]
    #[doc = " the function returns, it points to the srtp packet."]
    #[doc = ""]
    #[doc = " @param pkt_octet_len is a pointer to the length in octets of the"]
    #[doc = " complete RTCP packet (header and body) before the function call,"]
    #[doc = " and of the complete SRTCP packet after the call, if srtp_err_status_ok"]
    #[doc = " was returned.  Otherwise, the value of the data to which it points"]
    #[doc = " is undefined."]
    #[doc = ""]
    #[doc = " @param use_mki is a boolean to tell the system if mki is being used.  If"]
    #[doc = " set to false then will use the first set of session keys.  If set to true"]
    #[doc = " will"]
    #[doc = " use the session keys identified by the mki_index"]
    #[doc = ""]
    #[doc = " @param mki_index integer value specifying which set of session keys should be"]
    #[doc = " used if use_mki is set to true."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok            if there were no problems."]
    #[doc = "    - [other]                  if there was a failure in"]
    #[doc = "                               the cryptographic mechanisms."]
    pub fn srtp_protect_rtcp_mki(
        ctx: srtp_t,
        rtcp_hdr: *mut ::std::os::raw::c_void,
        pkt_octet_len: *mut ::std::os::raw::c_int,
        use_mki: ::std::os::raw::c_uint,
        mki_index: ::std::os::raw::c_uint,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_unprotect_rtcp() is the Secure RTCP receiver-side packet"]
    #[doc = " processing function."]
    #[doc = ""]
    #[doc = " The function call srtp_unprotect_rtcp(ctx, srtp_hdr, len_ptr)"]
    #[doc = " verifies the Secure RTCP protection of the SRTCP packet pointed to"]
    #[doc = " by srtcp_hdr (which has length *len_ptr), using the SRTP session"]
    #[doc = " context ctx.  If srtp_err_status_ok is returned, then srtcp_hdr points"]
    #[doc = " to the resulting RTCP packet and *len_ptr is the number of octets"]
    #[doc = " in that packet; otherwise, no assumptions should be made about the"]
    #[doc = " value of either data elements."]
    #[doc = ""]
    #[doc = " @warning This function assumes that the SRTCP packet is aligned on a"]
    #[doc = " 32-bit boundary."]
    #[doc = ""]
    #[doc = " @param ctx is a pointer to the srtp_t which applies to the"]
    #[doc = " particular packet."]
    #[doc = ""]
    #[doc = " @param srtcp_hdr is a pointer to the header of the SRTCP packet"]
    #[doc = " (before the call).  After the function returns, it points to the"]
    #[doc = " rtp packet if srtp_err_status_ok was returned; otherwise, the value of"]
    #[doc = " the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param pkt_octet_len is a pointer to the length in octets of the"]
    #[doc = " complete SRTCP packet (header and body) before the function call,"]
    #[doc = " and of the complete rtp packet after the call, if srtp_err_status_ok was"]
    #[doc = " returned.  Otherwise, the value of the data to which it points is"]
    #[doc = " undefined."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok          if the RTCP packet is valid."]
    #[doc = "    - srtp_err_status_auth_fail   if the SRTCP packet failed the message"]
    #[doc = "                             authentication check."]
    #[doc = "    - srtp_err_status_replay_fail if the SRTCP packet is a replay (e.g. has"]
    #[doc = "                             already been processed and accepted)."]
    #[doc = "    - [other]  if there has been an error in the cryptographic mechanisms."]
    #[doc = ""]
    pub fn srtp_unprotect_rtcp(
        ctx: srtp_t,
        srtcp_hdr: *mut ::std::os::raw::c_void,
        pkt_octet_len: *mut ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_unprotect_rtcp() is the Secure RTCP receiver-side packet"]
    #[doc = " processing function."]
    #[doc = ""]
    #[doc = " The function call srtp_unprotect_rtcp(ctx, srtp_hdr, len_ptr)"]
    #[doc = " verifies the Secure RTCP protection of the SRTCP packet pointed to"]
    #[doc = " by srtcp_hdr (which has length *len_ptr), using the SRTP session"]
    #[doc = " context ctx.  If srtp_err_status_ok is returned, then srtcp_hdr points"]
    #[doc = " to the resulting RTCP packet and *len_ptr is the number of octets"]
    #[doc = " in that packet; otherwise, no assumptions should be made about the"]
    #[doc = " value of either data elements."]
    #[doc = ""]
    #[doc = " @warning This function assumes that the SRTCP packet is aligned on a"]
    #[doc = " 32-bit boundary."]
    #[doc = ""]
    #[doc = " @param ctx is a pointer to the srtp_t which applies to the"]
    #[doc = " particular packet."]
    #[doc = ""]
    #[doc = " @param srtcp_hdr is a pointer to the header of the SRTCP packet"]
    #[doc = " (before the call).  After the function returns, it points to the"]
    #[doc = " rtp packet if srtp_err_status_ok was returned; otherwise, the value of"]
    #[doc = " the data to which it points is undefined."]
    #[doc = ""]
    #[doc = " @param pkt_octet_len is a pointer to the length in octets of the"]
    #[doc = " complete SRTCP packet (header and body) before the function call,"]
    #[doc = " and of the complete rtp packet after the call, if srtp_err_status_ok was"]
    #[doc = " returned.  Otherwise, the value of the data to which it points is"]
    #[doc = " undefined."]
    #[doc = ""]
    #[doc = " @param use_mki is a boolean to tell the system if mki is being used.  If"]
    #[doc = " set to false then will use the first set of session keys.  If set to true"]
    #[doc = " will use the session keys identified by the mki_index"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - srtp_err_status_ok          if the RTCP packet is valid."]
    #[doc = "    - srtp_err_status_auth_fail   if the SRTCP packet failed the message"]
    #[doc = "                                  authentication check."]
    #[doc = "    - srtp_err_status_replay_fail if the SRTCP packet is a replay (e.g. has"]
    #[doc = "                                  already been processed and accepted)."]
    #[doc = "    - srtp_err_status_bad_mki     if the MKI in the packet is not a known MKI"]
    #[doc = "                                  id"]
    #[doc = "    - [other]                     if there has been an error in the"]
    #[doc = "                                  cryptographic mechanisms."]
    #[doc = ""]
    pub fn srtp_unprotect_rtcp_mki(
        ctx: srtp_t,
        srtcp_hdr: *mut ::std::os::raw::c_void,
        pkt_octet_len: *mut ::std::os::raw::c_int,
        use_mki: ::std::os::raw::c_uint,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_set_user_data() stores the given pointer into the SRTP"]
    #[doc = " session for later retrieval."]
    #[doc = ""]
    #[doc = " @param ctx is the srtp_t context in which the given data pointer is"]
    #[doc = " stored."]
    #[doc = ""]
    #[doc = " @param data is a pointer to the custom information (struct, function,"]
    #[doc = " etc) associated with the SRTP session."]
    #[doc = ""]
    #[doc = " @return void."]
    #[doc = ""]
    pub fn srtp_set_user_data(ctx: srtp_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief srtp_get_user_data() retrieves the pointer to the custom data"]
    #[doc = " previously stored with srtp_set_user_data()."]
    #[doc = ""]
    #[doc = " This function is mostly useful for retrieving data associated to a"]
    #[doc = " SRTP session when an event fires. The user can then get such a custom"]
    #[doc = " data by calling this function with the session field of the"]
    #[doc = " srtp_event_data_t struct as argument."]
    #[doc = ""]
    #[doc = " @param ctx is the srtp_t context in which the given data pointer was"]
    #[doc = " stored."]
    #[doc = ""]
    #[doc = " @return void* pointer to the user data."]
    #[doc = ""]
    pub fn srtp_get_user_data(ctx: srtp_t) -> *mut ::std::os::raw::c_void;
}
#[doc = "< An SSRC collision occurred."]
pub const srtp_event_t_event_ssrc_collision: srtp_event_t = 0;
#[doc = "< An SRTP stream reached the soft key   */"]
pub const srtp_event_t_event_key_soft_limit: srtp_event_t = 1;
#[doc = "< An SRTP stream reached the hard       */"]
pub const srtp_event_t_event_key_hard_limit: srtp_event_t = 2;
#[doc = "< An SRTP stream reached the hard       */"]
pub const srtp_event_t_event_packet_index_limit: srtp_event_t = 3;
#[doc = " @brief srtp_event_t defines events that need to be handled"]
#[doc = ""]
#[doc = " The enum srtp_event_t defines events that need to be handled"]
#[doc = " outside the `data plane', such as SSRC collisions and"]
#[doc = " key expirations."]
#[doc = ""]
#[doc = " When a key expires or the maximum number of packets has been"]
#[doc = " reached, an SRTP stream will enter an `expired' state in which no"]
#[doc = " more packets can be protected or unprotected.  When this happens,"]
#[doc = " it is likely that you will want to either deallocate the stream"]
#[doc = " (using srtp_remove_stream()), and possibly allocate a new one."]
#[doc = ""]
#[doc = " When an SRTP stream expires, the other streams in the same session"]
#[doc = " are unaffected, unless key sharing is used by that stream.  In the"]
#[doc = " latter case, all of the streams in the session will expire."]
pub type srtp_event_t = u32;
#[doc = " @brief srtp_event_data_t is the structure passed as a callback to"]
#[doc = " the event handler function"]
#[doc = ""]
#[doc = " The struct srtp_event_data_t holds the data passed to the event"]
#[doc = " handler function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_event_data_t {
    #[doc = "< The session in which the event happened."]
    pub session: srtp_t,
    #[doc = "< The ssrc in host order of the stream in which  */"]
    pub ssrc: u32,
    #[doc = "< An enum indicating the type of event."]
    pub event: srtp_event_t,
}
#[test]
fn bindgen_test_layout_srtp_event_data_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_event_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(srtp_event_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_event_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_event_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_event_data_t>())).session as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_event_data_t),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_event_data_t>())).ssrc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_event_data_t),
            "::",
            stringify!(ssrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_event_data_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_event_data_t),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " @brief srtp_event_handler_func_t is the function prototype for"]
#[doc = " the event handler."]
#[doc = ""]
#[doc = " The typedef srtp_event_handler_func_t is the prototype for the"]
#[doc = " event handler function.  It has as its only argument an"]
#[doc = " srtp_event_data_t which describes the event that needs to be handled."]
#[doc = " There can only be a single, global handler for all events in"]
#[doc = " libSRTP."]
pub type srtp_event_handler_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut srtp_event_data_t)>;
extern "C" {
    #[doc = " @brief sets the event handler to the function supplied by the caller."]
    #[doc = ""]
    #[doc = " The function call srtp_install_event_handler(func) sets the event"]
    #[doc = " handler function to the value func.  The value NULL is acceptable"]
    #[doc = " as an argument; in this case, events will be ignored rather than"]
    #[doc = " handled."]
    #[doc = ""]
    #[doc = " @param func is a pointer to a function that takes an srtp_event_data_t"]
    #[doc = "             pointer as an argument and returns void.  This function"]
    #[doc = "             will be used by libSRTP to handle events."]
    pub fn srtp_install_event_handler(func: srtp_event_handler_func_t) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief Returns the version string of the library."]
    #[doc = ""]
    pub fn srtp_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the numeric representation of the library version."]
    #[doc = ""]
    pub fn srtp_get_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief srtp_set_debug_module(mod_name, v)"]
    #[doc = ""]
    #[doc = " sets dynamic debugging to the value v (0 for off, 1 for on) for the"]
    #[doc = " debug module with the name mod_name"]
    #[doc = ""]
    #[doc = " returns err_status_ok on success, err_status_fail otherwise"]
    pub fn srtp_set_debug_module(
        mod_name: *const ::std::os::raw::c_char,
        v: ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_list_debug_modules() outputs a list of debugging modules"]
    #[doc = ""]
    pub fn srtp_list_debug_modules() -> srtp_err_status_t;
}
#[doc = "< log level is reporting an error message"]
pub const srtp_log_level_t_srtp_log_level_error: srtp_log_level_t = 0;
#[doc = "< log level is reporting a warning message"]
pub const srtp_log_level_t_srtp_log_level_warning: srtp_log_level_t = 1;
#[doc = "< log level is reporting an info message"]
pub const srtp_log_level_t_srtp_log_level_info: srtp_log_level_t = 2;
#[doc = "< log level is reporting a debug message"]
pub const srtp_log_level_t_srtp_log_level_debug: srtp_log_level_t = 3;
#[doc = " @brief srtp_log_level_t defines log levels."]
#[doc = ""]
#[doc = " The enumeration srtp_log_level_t defines log levels reported"]
#[doc = " in the srtp_log_handler_func_t."]
#[doc = ""]
pub type srtp_log_level_t = u32;
#[doc = " @brief srtp_log_handler_func_t is the function prototype for"]
#[doc = " the log handler."]
#[doc = ""]
#[doc = " The typedef srtp_event_handler_func_t is the prototype for the"]
#[doc = " event handler function.  It has as srtp_log_level_t, log"]
#[doc = " message and data as arguments."]
#[doc = " There can only be a single, global handler for all log messages in"]
#[doc = " libSRTP."]
pub type srtp_log_handler_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: srtp_log_level_t,
        msg: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief sets the log handler to the function supplied by the caller."]
    #[doc = ""]
    #[doc = " The function call srtp_install_log_handler(func) sets the log"]
    #[doc = " handler function to the value func.  The value NULL is acceptable"]
    #[doc = " as an argument; in this case, log messages will be ignored."]
    #[doc = " This function can be called before srtp_init() in order to capture"]
    #[doc = " any logging during start up."]
    #[doc = ""]
    #[doc = " @param func is a pointer to a function of type srtp_log_handler_func_t."]
    #[doc = "             This function will be used by libSRTP to output log messages."]
    #[doc = " @param data is a user pointer that will be returned as the data argument in"]
    #[doc = " func."]
    pub fn srtp_install_log_handler(
        func: srtp_log_handler_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_get_protect_trailer_length(session, use_mki, mki_index, length)"]
    #[doc = ""]
    #[doc = " Determines the length of the amount of data Lib SRTP will add to the"]
    #[doc = " packet during the protect process. The length is returned in the length"]
    #[doc = " parameter"]
    #[doc = ""]
    #[doc = " returns err_status_ok on success, err_status_bad_mki if the MKI index is"]
    #[doc = " invalid"]
    #[doc = ""]
    pub fn srtp_get_protect_trailer_length(
        session: srtp_t,
        use_mki: u32,
        mki_index: u32,
        length: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_get_protect_rtcp_trailer_length(session, use_mki, mki_index,"]
    #[doc = " length)"]
    #[doc = ""]
    #[doc = " Determines the length of the amount of data Lib SRTP will add to the"]
    #[doc = " packet during the protect process. The length is returned in the length"]
    #[doc = " parameter"]
    #[doc = ""]
    #[doc = " returns err_status_ok on success, err_status_bad_mki if the MKI index is"]
    #[doc = " invalid"]
    #[doc = ""]
    pub fn srtp_get_protect_rtcp_trailer_length(
        session: srtp_t,
        use_mki: u32,
        mki_index: u32,
        length: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_set_stream_roc(session, ssrc, roc)"]
    #[doc = ""]
    #[doc = " Set the roll-over-counter on a session for a given SSRC"]
    #[doc = ""]
    #[doc = " returns err_status_ok on success, srtp_err_status_bad_param if there is no"]
    #[doc = " stream found"]
    #[doc = ""]
    pub fn srtp_set_stream_roc(session: srtp_t, ssrc: u32, roc: u32) -> srtp_err_status_t;
}
extern "C" {
    #[doc = " @brief srtp_get_stream_roc(session, ssrc, roc)"]
    #[doc = ""]
    #[doc = " Get the roll-over-counter on a session for a given SSRC"]
    #[doc = ""]
    #[doc = " returns err_status_ok on success, srtp_err_status_bad_param if there is no"]
    #[doc = " stream found"]
    #[doc = ""]
    pub fn srtp_get_stream_roc(session: srtp_t, ssrc: u32, roc: *mut u32) -> srtp_err_status_t;
}
#[doc = "< encryption (convert plaintext to ciphertext)"]
pub const srtp_cipher_direction_t_srtp_direction_encrypt: srtp_cipher_direction_t = 0;
#[doc = "< decryption (convert ciphertext to plaintext)"]
pub const srtp_cipher_direction_t_srtp_direction_decrypt: srtp_cipher_direction_t = 1;
#[doc = "< encryption or decryption"]
pub const srtp_cipher_direction_t_srtp_direction_any: srtp_cipher_direction_t = 2;
pub type srtp_cipher_direction_t = u32;
pub type srtp_cipher_pointer_t = *mut srtp_cipher_t;
pub type srtp_cipher_alloc_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        cp: *mut srtp_cipher_pointer_t,
        key_len: ::std::os::raw::c_int,
        tag_len: ::std::os::raw::c_int,
    ) -> srtp_err_status_t,
>;
pub type srtp_cipher_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, key: *const u8) -> srtp_err_status_t,
>;
pub type srtp_cipher_dealloc_func_t =
    ::std::option::Option<unsafe extern "C" fn(cp: srtp_cipher_pointer_t) -> srtp_err_status_t>;
pub type srtp_cipher_set_aad_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        aad: *const u8,
        aad_len: u32,
    ) -> srtp_err_status_t,
>;
pub type srtp_cipher_encrypt_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        octets_to_encrypt: *mut ::std::os::raw::c_uint,
    ) -> srtp_err_status_t,
>;
pub type srtp_cipher_set_iv_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        iv: *mut u8,
        direction: srtp_cipher_direction_t,
    ) -> srtp_err_status_t,
>;
pub type srtp_cipher_get_tag_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        tag: *mut u8,
        len: *mut u32,
    ) -> srtp_err_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_cipher_test_case_t {
    pub key_length_octets: ::std::os::raw::c_int,
    pub key: *const u8,
    pub idx: *mut u8,
    pub plaintext_length_octets: ::std::os::raw::c_uint,
    pub plaintext: *const u8,
    pub ciphertext_length_octets: ::std::os::raw::c_uint,
    pub ciphertext: *const u8,
    pub aad_length_octets: ::std::os::raw::c_int,
    pub aad: *const u8,
    pub tag_length_octets: ::std::os::raw::c_int,
    pub next_test_case: *const srtp_cipher_test_case_t,
}
#[test]
fn bindgen_test_layout_srtp_cipher_test_case_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_cipher_test_case_t>(),
        88usize,
        concat!("Size of: ", stringify!(srtp_cipher_test_case_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_cipher_test_case_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_cipher_test_case_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).key_length_octets as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(key_length_octets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).idx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).plaintext_length_octets as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(plaintext_length_octets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).plaintext as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(plaintext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).ciphertext_length_octets as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(ciphertext_length_octets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).ciphertext as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(ciphertext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).aad_length_octets as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(aad_length_octets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).aad as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(aad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).tag_length_octets as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(tag_length_octets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srtp_cipher_test_case_t>())).next_test_case as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_test_case_t),
            "::",
            stringify!(next_test_case)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_cipher_type_t {
    pub alloc: srtp_cipher_alloc_func_t,
    pub dealloc: srtp_cipher_dealloc_func_t,
    pub init: srtp_cipher_init_func_t,
    pub set_aad: srtp_cipher_set_aad_func_t,
    pub encrypt: srtp_cipher_encrypt_func_t,
    pub decrypt: srtp_cipher_encrypt_func_t,
    pub set_iv: srtp_cipher_set_iv_func_t,
    pub get_tag: srtp_cipher_get_tag_func_t,
    pub description: *const ::std::os::raw::c_char,
    pub test_data: *const srtp_cipher_test_case_t,
    pub id: srtp_cipher_type_id_t,
}
#[test]
fn bindgen_test_layout_srtp_cipher_type_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_cipher_type_t>(),
        88usize,
        concat!("Size of: ", stringify!(srtp_cipher_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_cipher_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_cipher_type_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).dealloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(dealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).set_aad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(set_aad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).encrypt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).decrypt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).set_iv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(set_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).get_tag as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(get_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).description as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).test_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(test_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_type_t>())).id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_type_t),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_cipher_t {
    pub type_: *const srtp_cipher_type_t,
    pub state: *mut ::std::os::raw::c_void,
    pub key_len: ::std::os::raw::c_int,
    pub algorithm: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_srtp_cipher_t() {
    assert_eq!(
        ::std::mem::size_of::<srtp_cipher_t>(),
        24usize,
        concat!("Size of: ", stringify!(srtp_cipher_t))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_cipher_t>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_cipher_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_t>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_t>())).key_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_t),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_cipher_t>())).algorithm as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_cipher_t),
            "::",
            stringify!(algorithm)
        )
    );
}
extern "C" {
    pub fn srtp_cipher_get_key_length(c: *const srtp_cipher_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srtp_cipher_type_self_test(ct: *const srtp_cipher_type_t) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_type_test(
        ct: *const srtp_cipher_type_t,
        test_data: *const srtp_cipher_test_case_t,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_bits_per_second(
        c: *mut srtp_cipher_t,
        octets_in_buffer: ::std::os::raw::c_int,
        num_trials: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    pub fn srtp_cipher_type_alloc(
        ct: *const srtp_cipher_type_t,
        c: *mut *mut srtp_cipher_t,
        key_len: ::std::os::raw::c_int,
        tlen: ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_dealloc(c: *mut srtp_cipher_t) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_init(c: *mut srtp_cipher_t, key: *const u8) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_set_iv(
        c: *mut srtp_cipher_t,
        iv: *mut u8,
        direction: ::std::os::raw::c_int,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_output(
        c: *mut srtp_cipher_t,
        buffer: *mut u8,
        num_octets_to_output: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_encrypt(
        c: *mut srtp_cipher_t,
        buffer: *mut u8,
        num_octets_to_output: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_decrypt(
        c: *mut srtp_cipher_t,
        buffer: *mut u8,
        num_octets_to_output: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_get_tag(
        c: *mut srtp_cipher_t,
        buffer: *mut u8,
        tag_len: *mut u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_cipher_set_aad(
        c: *mut srtp_cipher_t,
        aad: *const u8,
        aad_len: u32,
    ) -> srtp_err_status_t;
}
extern "C" {
    pub fn srtp_replace_cipher_type(
        ct: *const srtp_cipher_type_t,
        id: srtp_cipher_type_id_t,
    ) -> srtp_err_status_t;
}
